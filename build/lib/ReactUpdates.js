define("kg/react/0.0.2/lib/ReactUpdates",["./CallbackQueue","./PooledClass","./ReactCurrentOwner","./ReactPerf","./Transaction","./Object.assign","./invariant","./warning"],function(e,t,n){"use strict";function a(){"production"!==process.env.NODE_ENV?b(_.ReactReconcileTransaction&&y,"ReactUpdates: must inject a reconcile transaction class and batching strategy"):b(_.ReactReconcileTransaction&&y)}function c(){this.reinitializeTransaction(),this.dirtyComponentsLength=null,this.callbackQueue=u.getPooled(),this.reconcileTransaction=_.ReactReconcileTransaction.getPooled()}function o(e,t,n){a(),y.batchedUpdates(e,t,n)}function i(e,t){return e._mountDepth-t._mountDepth}function s(e){var t=e.dirtyComponentsLength;"production"!==process.env.NODE_ENV?b(t===m.length,"Expected flush transaction's stored dirty-components length (%s) to match dirty-components array length (%s).",t,m.length):b(t===m.length),m.sort(i);for(var n=0;t>n;n++){var a=m[n];if(a.isMounted()){var c=a._pendingCallbacks;if(a._pendingCallbacks=null,a.performUpdateIfNecessary(e.reconcileTransaction),c)for(var o=0;o<c.length;o++)e.callbackQueue.enqueue(c[o],a)}}}function r(e,t){return"production"!==process.env.NODE_ENV?b(!t||"function"==typeof t,"enqueueUpdate(...): You called `setProps`, `replaceProps`, `setState`, `replaceState`, or `forceUpdate` with a callback that isn't callable."):b(!t||"function"==typeof t),a(),"production"!==process.env.NODE_ENV?U(null==d.current,"enqueueUpdate(): Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate."):null,y.isBatchingUpdates?(m.push(e),void(t&&(e._pendingCallbacks?e._pendingCallbacks.push(t):e._pendingCallbacks=[t]))):void y.batchedUpdates(r,e,t)}function l(e,t){"production"!==process.env.NODE_ENV?b(y.isBatchingUpdates,"ReactUpdates.asap: Can't enqueue an asap callback in a context whereupdates are not being batched."):b(y.isBatchingUpdates),v.enqueue(e,t),R=!0}var u=e("./CallbackQueue"),p=e("./PooledClass"),d=e("./ReactCurrentOwner"),h=e("./ReactPerf"),f=e("./Transaction"),g=e("./Object.assign"),b=e("./invariant"),U=e("./warning"),m=[],v=u.getPooled(),R=!1,y=null,E={initialize:function(){this.dirtyComponentsLength=m.length},close:function(){this.dirtyComponentsLength!==m.length?(m.splice(0,this.dirtyComponentsLength),T()):m.length=0}},N={initialize:function(){this.callbackQueue.reset()},close:function(){this.callbackQueue.notifyAll()}},C=[E,N];g(c.prototype,f.Mixin,{getTransactionWrappers:function(){return C},destructor:function(){this.dirtyComponentsLength=null,u.release(this.callbackQueue),this.callbackQueue=null,_.ReactReconcileTransaction.release(this.reconcileTransaction),this.reconcileTransaction=null},perform:function(e,t,n){return f.Mixin.perform.call(this,this.reconcileTransaction.perform,this.reconcileTransaction,e,t,n)}}),p.addPoolingTo(c);var T=h.measure("ReactUpdates","flushBatchedUpdates",function(){for(;m.length||R;){if(m.length){var e=c.getPooled();e.perform(s,null,e),c.release(e)}if(R){R=!1;var t=v;v=u.getPooled(),t.notifyAll(),u.release(t)}}}),k={injectReconcileTransaction:function(e){"production"!==process.env.NODE_ENV?b(e,"ReactUpdates: must provide a reconcile transaction class"):b(e),_.ReactReconcileTransaction=e},injectBatchingStrategy:function(e){"production"!==process.env.NODE_ENV?b(e,"ReactUpdates: must provide a batching strategy"):b(e),"production"!==process.env.NODE_ENV?b("function"==typeof e.batchedUpdates,"ReactUpdates: must provide a batchedUpdates() function"):b("function"==typeof e.batchedUpdates),"production"!==process.env.NODE_ENV?b("boolean"==typeof e.isBatchingUpdates,"ReactUpdates: must provide an isBatchingUpdates boolean attribute"):b("boolean"==typeof e.isBatchingUpdates),y=e}},_={ReactReconcileTransaction:null,batchedUpdates:o,enqueueUpdate:r,flushBatchedUpdates:T,injection:k,asap:l};n.exports=_});