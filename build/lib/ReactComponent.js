define("kg/react/0.0.2/lib/ReactComponent",["./ReactElement","./ReactOwner","./ReactUpdates","./Object.assign","./invariant","./keyMirror"],function(e,n,t){"use strict";var o=e("./ReactElement"),i=e("./ReactOwner"),r=e("./ReactUpdates"),s=e("./Object.assign"),p=e("./invariant"),c=e("./keyMirror"),u=c({MOUNTED:null,UNMOUNTED:null}),a=!1,l=null,m=null,d={injection:{injectEnvironment:function(e){"production"!==process.env.NODE_ENV?p(!a,"ReactComponent: injectEnvironment() can only be called once."):p(!a),m=e.mountImageIntoNode,l=e.unmountIDFromEnvironment,d.BackendIDOperations=e.BackendIDOperations,a=!0}},LifeCycle:u,BackendIDOperations:null,Mixin:{isMounted:function(){return this._lifeCycleState===u.MOUNTED},setProps:function(e,n){var t=this._pendingElement||this._currentElement;this.replaceProps(s({},t.props,e),n)},replaceProps:function(e,n){"production"!==process.env.NODE_ENV?p(this.isMounted(),"replaceProps(...): Can only update a mounted component."):p(this.isMounted()),"production"!==process.env.NODE_ENV?p(0===this._mountDepth,"replaceProps(...): You called `setProps` or `replaceProps` on a component with a parent. This is an anti-pattern since props will get reactively updated when rendered. Instead, change the owner's `render` method to pass the correct value as props to the component where it is created."):p(0===this._mountDepth),this._pendingElement=o.cloneAndReplaceProps(this._pendingElement||this._currentElement,e),r.enqueueUpdate(this,n)},_setPropsInternal:function(e,n){var t=this._pendingElement||this._currentElement;this._pendingElement=o.cloneAndReplaceProps(t,s({},t.props,e)),r.enqueueUpdate(this,n)},construct:function(e){this.props=e.props,this._owner=e._owner,this._lifeCycleState=u.UNMOUNTED,this._pendingCallbacks=null,this._currentElement=e,this._pendingElement=null},mountComponent:function(e,n,t){"production"!==process.env.NODE_ENV?p(!this.isMounted(),"mountComponent(%s, ...): Can only mount an unmounted component. Make sure to avoid storing components between renders or reusing a single component instance in multiple places.",e):p(!this.isMounted());var o=this._currentElement.ref;if(null!=o){var r=this._currentElement._owner;i.addComponentAsRefTo(this,o,r)}this._rootNodeID=e,this._lifeCycleState=u.MOUNTED,this._mountDepth=t},unmountComponent:function(){"production"!==process.env.NODE_ENV?p(this.isMounted(),"unmountComponent(): Can only unmount a mounted component."):p(this.isMounted());var e=this._currentElement.ref;null!=e&&i.removeComponentAsRefFrom(this,e,this._owner),l(this._rootNodeID),this._rootNodeID=null,this._lifeCycleState=u.UNMOUNTED},receiveComponent:function(e,n){"production"!==process.env.NODE_ENV?p(this.isMounted(),"receiveComponent(...): Can only update a mounted component."):p(this.isMounted()),this._pendingElement=e,this.performUpdateIfNecessary(n)},performUpdateIfNecessary:function(e){if(null!=this._pendingElement){var n=this._currentElement,t=this._pendingElement;this._currentElement=t,this.props=t.props,this._owner=t._owner,this._pendingElement=null,this.updateComponent(e,n)}},updateComponent:function(e,n){var t=this._currentElement;(t._owner!==n._owner||t.ref!==n.ref)&&(null!=n.ref&&i.removeComponentAsRefFrom(this,n.ref,n._owner),null!=t.ref&&i.addComponentAsRefTo(this,t.ref,t._owner))},mountComponentIntoNode:function(e,n,t){var o=r.ReactReconcileTransaction.getPooled();o.perform(this._mountComponentIntoNode,this,e,n,o,t),r.ReactReconcileTransaction.release(o)},_mountComponentIntoNode:function(e,n,t,o){var i=this.mountComponent(e,t,0);m(i,n,o)},isOwnedBy:function(e){return this._owner===e},getSiblingByRef:function(e){var n=this._owner;return n&&n.refs?n.refs[e]:null}}};t.exports=d});