<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>reactive</title>
    <link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="http://docs.kissyui.com/1.4/source/guideline/templates/assets/com-prettify.css">
    <link rel="stylesheet" href="http://docs.kissyui.com/1.4/source/guideline/templates/assets/com.css">
    <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
    <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <script src="http://cdn.staticfile.org/prettify/r298/prettify.min.js"></script>
    <script src="http://g.tbcdn.cn/kissy/k/1.4.8/seed-min.js" data-config="{combine:true}"></script>
  </head>
  <body data-spy="scroll" data-target=".bs-docs-sidebar">
    <div id="header"><a href="http://docs.kissyui.com/" class="logo">kissy</a>
      <nav><a href="http://docs.kissyui.com/1.4/docs/html/coms.html">优秀组件推荐</a></nav>
    </div>
    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span3 bs-docs-sidebar">
          <ul data-spy="affix" data-offset-top="0" class="nav nav-list bs-docs-sidenav"></ul>
        </div>
        <div class="span9 bs-docs-content">
          <h1 data-id="undefined" class="title">reactive</h1>
          <p class="author-wrapper"><span>组件有问题？旺旺联系作者：</span><a href="https://github.com/yiminghe" target="_blank" data-name="承玉" class="author"><img src="https://avatars.githubusercontent.com/u/200876?v=3&amp;s=60" alt="承玉"></a><span class="author-name">承玉</span>
          </p>
          <div class="common-link"><a href="../demo/index.html" target="_blank" class="demo">示例</a><a href="https://github.com/kissygalleryteam/reactive" target="_blank" class="source">源码</a></div>
          <p class="com-info"><span class="info-label">View</span><span data-com="reactive" class="J_View">532</span></p>
          <p class="com-info"><span class="info-label">所属分类</span><a href="http://kpm.taobao.net/list/框架&amp;工具">框架&amp;工具</a><span class="info-label tag-label">组件标签</span><a href="http://kpm.taobao.net/list/tag?tag=reac">reac</a>
          </p>
          <p class="com-info"><span class="info-label">kissy版本</span><span>1.4.X</span>
          </p><p>原文地址: <a href="http://blog.kissyui.com/2014/08/07/functional-reactive-programming/">http://blog.kissyui.com/2014/08/07/functional-reactive-programming/</a></p>
<p><a href="http://en.wikipedia.org/wiki/Functional_reactive_programming">function reactive programming</a> (frp) 是一种函数式语言的编程范式，通过响应式的编程可以构建出事件流，事件流可以再通过函数式的转换/过滤/<strong>组合</strong>，最终形成可用的结果。同 promise 类似可以有效得消除异步调用场景下的嵌套回调。和 promise 侧重于一次性的成功/失败不同，frp 则侧重于离散的源源不断的事件流。</p>
<p>frp 根据概念和实现的差别并没有一致的约定，这里介绍 kissy frp 的 api 及其用法，详细的概念介绍参见：<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you&#39;ve been missing</a>.</p>
<h2 id="api">api</h2>
<h3 id="-">类</h3>
<p>EventStream 事件流类</p>
<p>Property 属性类，继承于事件流类</p>
<h3 id="-">构建方法</h3>
<p>createEventStream: 构建一个事件流 (EventStream)，然后可以往事件流中添加值，例如</p>
<pre><code class="lang-javascript">reactive.createEventStream(function(fire){
  fire(&#39;something&#39;)
});
</code></pre>
<p>createProperty: 构建一个属性 (Property)，属性和事件的区别在于后面 onValue 的处理不同.</p>
<h3 id="-">实例方法</h3>
<p>EventStream.prototype.onValue 监听事件流所添加的值</p>
<p>Property.prototype.onValue 监听属性的最近一个值，和 EventStream 的区别点在于如果先在事件流中添加值然后再监听，事件流中的值会监听不到（已经触发）。而 property 会缓存最近的值，在 onValue 会取出来缓存的值。</p>
<p>EventStream.prototype.startsWith 设置事件流的初始值, 在 onValue 时立即取出来使用</p>
<h3 id="-">函数式方法</h3>
<p>EventStream.prototype.combine 将多个流组合为一个流，这个流的事件值为多个流事件值的组合，例如</p>
<pre><code class="lang-javascript">stream1 = reactive.createEventStream(function(fire){
  fire(1)
});
stream2 = reactive.createEventStream(function(fire){
  fire(2)
});
stream3 = stream1.combine(stream2);
stream3.onValue(function(v){
  v // =&gt; [1,2]
});
</code></pre>
<p>EventStream.prototype.filter 返回一个新的事件流，该事件流只有在当前事件流的值通过过滤时才添加值，例如</p>
<pre><code class="lang-javascript">stream2 = stream1.filter(function(v){
    return v&gt;1;
});
</code></pre>
<p>EventStream.prototype.map 返回一个新的事件流，该事件流是对当前事件流转换的结果，结果可以又是一个事件流，即形成一种委托的关系。</p>
<p>例如简单的转换</p>
<pre><code class="lang-javascript">stream2 = stream1.map(function(v){
  return 2*v;
});
</code></pre>
<p>或者嵌套的转换，新的事件流的值又是由另一个事件流产生，常用于异步的场景</p>
<pre><code class="lang-javascript">stream2 = stream1.map(function(v){
  return reactive.createEventStream(function(fire){
       setTimeout(function(){
          fire(v+1);
       },100);
  });
});
</code></pre>
<h2 id="example">example</h2>
<p>api 很少，用起来也很简单，这里举两个简单的例子说明下：</p>
<h4 id="-">自动补全</h4>
<p><a href="http://gallery.kissyui.com/reactive/doc/demo/autocomplete.html">demo</a>, 自动补全是一个 frp 合适而且简单的应用场景， 初始事件流就是用户对于单个 input 的输入，该事件流经过简单的过滤（非空），转换为对于服务器请求的事件流，最终服务器返回后的值作为结果渲染。示例代码如下：</p>
<pre><code class="lang-javascript">// 初始事件流
reactive.createEventStream(function(fire){
   input[0].oninput = function () {
     fire(this.value);
   };
})
// 过滤
.filter(function(v){
  return !!v.trim();
})
// 去空格
.map(function(v){
  return v.trim();
})
// 转化为服务器请求流
.map(function(v){
  return reactive.createEventStream(function(fire){
    io.jsonp(&#39;xx.json&#39;,{q:v},function(data){
        fire(data)
    });
  });
})
// 获取最终值
.onValue(function(data){
   // render data
});
</code></pre>
<p>大家可以想下以前用回调是如果实现的，而 frp 则有效得使用组合替代了嵌套回调。</p>
<h4 id="-">计算器</h4>
<p><a href="http://gallery.kissyui.com/reactive/doc/demo/index.html">demo</a> ，计算器则演示了多个事件流的组合性，用户在每个输入框的输入都形成了一个事件流，而多个事件流组合的结果经过计算形成了最终的计算结果。示例代码如下</p>
<pre><code class="lang-javascript">// 事件流1
reactive.createEventStream(function(fire){
   input1.oninput = function () {
     fire(this.value);
   };
})
// 组合事件流2
.combine(reactive.createEventStream(function(fire){
   input2.oninput = function () {
     fire(this.value);
   };
}))
// 转换结果
.map(function(v){
  return v[0]+v[1];
})
// 渲染最终值
.onValue(function(v){
});
</code></pre>
<h2 id="-">现在就使用</h2>
<p>在 kissy 中可以通过配置 <a href="http://gallery.kissyui.com/reactive/doc/guide/index.html">gallery</a> 包 kg 为 <a href="http://g.tbcdn.cn/kg/">http://g.tbcdn.cn/kg/</a> 然后 use(&#39;kg/reactive/0.2.0/&#39;) 即可。</p>
<p>gallery 组件现在也可以使用 bower 安装到本地（公司内部），配置 .bowerrc 为 </p>
<pre><code class="lang-javascript">{
    &quot;shorthand_resolver&quot;:&quot;http://gitlab.alibaba-inc.com/{{{owner}}}/{{{package}}}.git&quot;
}
</code></pre>
<p>添加 bower.json</p>
<pre><code class="lang-javascript">{
    &quot;name&quot;: &quot;test-project&quot;,
    &quot;private&quot;: true,
    &quot;dependencies&quot;: {
        &quot;reactive&quot;: &quot;kg/reactive&quot;
    }
}
</code></pre>
<p>在根目录执行 bower  install 即可安装组件到本地 bower_components 目录，目录可以通过在 .bowerrc 中配置 directory 改变，详见： <a href="http://bower.io/docs/config/">bower 文档</a></p>

          <div style="display:none;"><script type="text/javascript" src="http://tajs.qq.com/stats?sId=36378479" charset="UTF-8"></script></div>
          <script src="http://docs.kissyui.com/1.4/source/guideline/templates/assets/com.js"></script>
        </div>
      </div>
    </div>
  </body>
</html>